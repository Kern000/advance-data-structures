// will code out quick sort and merge sort since for time complexity, they tend to be the fastest

// bubble sort - compare ea adj and arrange in order - worst and best O(n**2)
// selection sort - asume first element is min, keep swapping new min and assumed min - worst and best time complexity is O(n**2)
// insertion sort - starts with the first element and, for each subsequent element, compares it with the already sorted portion and inserts it at the correct position. best case O(n) worst is same as above
// The above hv space complexity O(1);
// Quick sort worst case O(n**2), best case O(nlogn); space complexity O(n);
// Merge sort worst and best case O(nlogn) for time complexity, O(n) for space complexity

